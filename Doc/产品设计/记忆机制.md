# 记忆机制设计（Memory Architecture）


🧠 记忆架构的核心思想：

📚 长期记忆：旅行信息表
性质：相对稳定的用户偏好和约束
作用：为旅游规划提供持续的指导原则
内容：目的地、时间、人数、预算、偏好等基础信息


🧩 短期记忆：行程表
性质：当前规划会话的具体结果
作用：承载实时的规划状态和AI交互内容
内容：具体的景点、时间、路线安排


🔄 记忆协同工作机制：
版本管理 = 长期记忆 + 短期记忆快照  
状态保存 = 双重记忆的持久化   
增量优化 = 长期记忆指导短期记忆演化  

这样的架构设计非常符合人类规划旅行的认知模式：

我们有相对固定的旅行偏好（长期记忆）
每次具体规划都是基于这些偏好的实时决策（短期记忆）
规划过程就是让短期记忆在长期记忆指导下不断优化


> 核心决策：**用户发给大模型的旅行信息文本直接作为长期记忆存储**，无需格式转换。当上下文窗口不足时，优先保留此原始文本。
> 
> 优势：1) 保持用户原始表达的自然性；2) 避免信息损失和格式转换错误；3) 便于系统直接引用和模型理解；4) 简化实现逻辑。多轮、可迭代的智能规划。
---

## 1. 记忆分层目标
| 层级 | 名称 | 角色定位 | 变化频率 | 典型载体 | 持久化方式 |
|------|------|----------|----------|----------|------------|
| L1 | 长期记忆 (User Profile) | 约束+偏好基线 | 低 | 旅行信息表 JSON | 会话内缓存（后续可扩展 DB 持久化） |
| L2 | 短期记忆 (Active Itinerary) | 当前规划状态 | 中 | 行程表结构化 JSON | 内存结构 + 临时快照（会话结束失效） |
| L3 | 临时上下文 (Ephemeral Dialog) | 解释/推理过程 | 高 | 对话消息列表 | 不持久（随裁剪/过期丢弃） |

> 设计原则：当上下文长度接近模型上限时，优先保留 L1 + L2，按权重裁剪 L3。
> 注意：当前系统会话是无状态的（会话结束后上下文不可恢复）。所谓“长期/短期记忆”的保存，均指**同一活跃会话生命周期内**的保留与复用；跨会话不会自动延续，除非后续实现外部持久化存储层。


--

## 2. 数据结构建议
### 2.1 长期记忆（旅行信息表）
> 决策：发给大模型时使用“结构化自然语言文本”而非 JSON；JSON 仅作为内部存储/比对/快照格式。这样做的原因：
> 1) 可读性更高，便于模型对语义段落整段理解；2) 减少因模型补全 JSON 严格格式而引入的语法噪声。

#### 2.1.1 长期记忆存储格式
> 直接存储用户发送的原始文本，无格式转换：

```
我的旅行信息如下：
- 旅行日期：2025-09-30 至 2025-10-02  
- 出行人数：共6人
  * 5岁以下儿童：1人
  * 5-12岁儿童：1人
  * 60岁以上老人：1人
- 旅行预算：30000元（不含往返路费）
- 旅行目的：亲子游玩、看演唱会、休闲度假
- 旅游偏好：
  * 住宿类型：五星级酒店
  * 出行方式：打车
  * 餐饮选择：海南菜、海鲜

请根据以上信息，为我规划一份详细的海口旅游行程。
```

#### 2.1.2 实际使用示例
> 以下为前端用户实际填写并发送给大模型的旅行信息表文本格式：

```
我的旅行信息如下：
- 旅行日期：2025-09-30 至 2025-10-02
- 出行人数：共6人
  * 5岁以下儿童：1人
  * 5-12岁儿童：1人
  * 60岁以上老人：1人
- 旅行预算：30000元（不含往返路费）
- 旅行目的：亲子游玩、看演唱会、休闲度假
- 旅游偏好：
  * 住宿类型：五星级酒店
  * 出行方式：打车
  * 餐饮选择：海南菜、海鲜

请根据以上信息，为我规划一份详细的海口旅游行程。
```




### 2.2 短期记忆（行程表）
> 下列示例与 `Doc/产品功能（已实现）/行程表.md` 中“标准数据格式”保持一致，并补充一个用于上下文保留的压缩（裁剪后）版本。

#### 2.2.1 运行期完整格式（runtime_full）
```json
{
  "days": [
    {
      "date": "2025-09-01",
      "day_number": 1,
      "locations": [
        {
          "address": "海口骑楼老街",
          "time": "09:00",
          "notes": "建议穿舒适的鞋子，可以拍照留念",
          "fixed": false,
          "visit_order": 1
        },
        {
          "address": "老爸茶(骑楼店)",
          "time": "12:00",
          "notes": "推荐海南粉、清补凉",
          "fixed": false,
          "visit_order": 2
        },
        {
          "address": "海口五源河体育场演唱会",
          "time": "18:30",
          "notes": "19:30开场，建议提前1小时到达。已购买门票",
          "fixed": true,
          "visit_order": 3
        }
      ]
    }
  ]
}
```


---

## 3. 上下文裁剪策略

### 3.1 新的上下文窗口结构
> 当上下文过长时，采用三元素保留策略：

```
{
  [长期记忆(旅行信息表)], 
  [短期记忆(行程表)], 
  [用户的最后一条消息]
}
```

### 3.2 裁剪原则
- **完整保留**：长期记忆（旅行信息表原始文本）
- **完整保留**：短期记忆（当前行程表完整结构化数据）
- **仅保留最新**：用户的最后一条消息
- **丢弃内容**：中间对话历史、解释性内容、推理过程

### 3.3 触发条件
- 上下文长度接近模型token限制（如8000+ tokens）
- 对话轮次超过预设阈值
- 系统内存使用达到警戒线

### 3.4 实施效果
- **压缩比**：从完整对话的8000+ tokens压缩至完整核心信息（长期记忆+完整行程表+最新消息）
- **保留核心**：用户需求基线 + 完整当前规划状态 + 最新指令
- **信息损失**：最小化，仅丢弃推理过程和历史交互，保留所有规划结果

---

